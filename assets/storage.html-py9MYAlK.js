import{_ as r,r as i,o as t,c as s,a as e,d as a,e as n,b as d}from"./app--ias0FLC.js";const h={},c=d('<h2 id="概要" tabindex="-1"><a class="header-anchor" href="#概要" aria-hidden="true">#</a> 概要</h2><p>目前，浏览器本地存储主要分为 cookie、Web Storage 以及 IndexedDB。其中 Web Storage 又可以分为我们所熟知的 sessionStorage 和 localStorage 两种。</p><h2 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> cookie</h2><p>cookie 通常由服务端生成，客户端维护，之后发送请求时会带上cookie储存的内容。cookie 可以用于标识客户端，能够让使用无状态 HTTP 协议的服务器记住登陆状态信息。</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><p>会话状态管理例如，个性化设置例如用户自定义主题等，浏览器行为跟踪（如跟踪分析用户行为等）。<br> 浏览器行为跟踪是指数字营销战略的一部分，从本质上讲，通过更多地了解你的在线活动，以便向你展示吸引你兴趣的广告。</p><h3 id="相关属性" tabindex="-1"><a class="header-anchor" href="#相关属性" aria-hidden="true">#</a> 相关属性</h3><ul><li>Expires 属性用于设置过期时间，Max-Age 用于设置有效时间段，过期后 cookie 会被删除。</li><li>Secure 属性代表 cookie 只会随 HTTPS 请求发送。</li><li>HttpOnly 属性代表 cookie 只用于发送给服务端，无法被 JavaScript 访问。</li><li>Domain 属性设置可接收 cookie 的 hosts，不设置则默认为当前 host。如果设置了 Domain，子域名也被包含在内。</li><li>Path 属性设置可接收 cookie 的 URL path，只有包含指定路径的 url 请求才会带上 cookie。如设置为 “/”，则子路径也包含在内。</li><li>SameSite 属性表示跨域时 cookie 的处理策略，包括 Strict, Lax 和 None。 --Strcit：cookie 只会在第一方上下文中发送，不会与第三方网站发起的请求一起发送。 --Lax：cookie 允许与顶级导航一起发送，并将与第三方网站发起的 GET 请求一起发送，这也是浏览器的默认值。 --None：cookie 将在所有上下文中发送，即允许跨域发送。使用 None 时，需在最新的浏览器版本中同时使用 Secure 属性，否则会报错。</li></ul><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><p>cookie具有简单易用，不占用服务器资源的资源，也可以通过设置过期时间，提升安全性。但是它会被添加在每个请求中，增加了流量消耗，此外在 HTTP 请求中cookie是明文传输的，不够安全，使用 HTTPS 可避免该问题；最后其大小限制在 4KB，复杂场景会不够用。</p><h2 id="sessionstorage" tabindex="-1"><a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a> sessionStorage</h2><p>sessionStorage 生命周期同当前tab页面保持一致，页面关闭时 sessionStorage 会被清空。sessionStorage 以键值对的方式存储数据，键值以字符串存储，一般为5mb。</p><h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1" aria-hidden="true">#</a> 使用场景</h3><p>sessionStorage 更适合用来存储生命周期和tab页同步的信息。</p><h3 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1" aria-hidden="true">#</a> 特点</h3><ul><li>sessionStorage 只属于当前tab页。</li><li>刷新tab页或恢复tab页面时保留 sessionStorage。</li><li>在页面触发打开新页面时，会复制会话上下文作为新会话的上下文。</li><li>复制tab页（浏览器标签右键菜单中的复制，非复制 URL）时会复制当前 sessionStorage 到新的tab页中。</li></ul><h2 id="localstorge" tabindex="-1"><a class="header-anchor" href="#localstorge" aria-hidden="true">#</a> localStorge</h2><p>localStorage 存储的数据可以tab页访问，大小同样为5mb。</p><h3 id="与sessionstorage的区别" tabindex="-1"><a class="header-anchor" href="#与sessionstorage的区别" aria-hidden="true">#</a> 与sessionStorage的区别</h3><p>localStorage 没有过期时间，但隐私窗口中的 localStorage 在最后一个隐私窗口关闭时会被清空。StorageEvent 只能监听同源页面的 localStorage 的改变，无法监听 sessionStorage 的改变。</p><h3 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2" aria-hidden="true">#</a> 使用场景</h3><p>理论上基本所有的存取数据，都可以使用 localStorage 来处理，但是由于它不会销毁的特点，涉及安全或时效的信息不建议使用，但我们可以利用它实现跨页面通信。</p><h2 id="indexeddb" tabindex="-1"><a class="header-anchor" href="#indexeddb" aria-hidden="true">#</a> indexedDB</h2>',23),l={href:"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API",target:"_blank",rel:"noopener noreferrer"},b=e("h3",{id:"使用场景-3",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#使用场景-3","aria-hidden":"true"},"#"),a(" 使用场景")],-1),g=e("p",null,"存储数据量很大，或者为结构化数据例如二进制文件等，对数据搜索有性能要求的场景。但是它是异步的，无法完全覆盖localStorge的使用场景。",-1);function p(S,x){const o=i("ExternalLinkIcon");return t(),s("div",null,[c,e("p",null,[a("其实一般开发中不使用，IndexedDB 是一种底层 API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该 API 使用索引实现对数据的高性能搜索。虽然 Web Storage 在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而 IndexedDB 提供了这种场景的解决方案。本页面 MDN IndexedDB 的主要引导页 - 这里，我们提供了完整的 API 参考和使用指南，浏览器支持细节，以及关键概念的一些解释的链接。"),e("a",l,[a("IndexedDB"),n(o)])]),b,g])}const k=r(h,[["render",p],["__file","storage.html.vue"]]);export{k as default};
