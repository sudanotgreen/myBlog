import{_ as a,o as t,c as p,a as n,d as s,b as o}from"./app--ias0FLC.js";const e={},c=n("p",null,"给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。",-1),l=n("p",null,[s("每分钟，如果节点满足以下全部条件，就会被感染："),n("br"),s(" 节点此前还没有感染。"),n("br"),s(" 节点与一个已感染节点相邻。"),n("br"),s(" 返回感染整棵树需要的分钟数。")],-1),u=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"TIP"),n("p",null,"实际上所需要的感染时间等于以感染节点为子树的深度，与除去感染节点子树剩下树以感染点为固定点的树的直径。")],-1),i=o(`<p>实现code, 参考灵茶山艾府：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> start<span class="token punctuation">;</span>

    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">auto</span> <span class="token punctuation">[</span>l_len<span class="token punctuation">,</span> l_found<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> <span class="token punctuation">[</span>r_len<span class="token punctuation">,</span> r_found<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>val <span class="token operator">==</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 计算子树 start 的最大深度</span>
            <span class="token comment">// 注意这里和方法一的区别，max 后面没有 +1，所以算出的也是最大深度</span>
            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>l_len<span class="token punctuation">,</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 找到了 start</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l_found <span class="token operator">||</span> r_found<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 只有在左子树或右子树包含 start 时，才能更新答案</span>
            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> l_len <span class="token operator">+</span> r_len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 两条链拼成直径</span>
            <span class="token comment">// 保证 start 是直径端点</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">(</span>l_found <span class="token operator">?</span> l_len <span class="token operator">:</span> r_len<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token function">max</span><span class="token punctuation">(</span>l_len<span class="token punctuation">,</span> r_len<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">amountOfTime</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),r=[c,l,u,i];function k(d,v){return t(),p("div",null,r)}const b=a(e,[["render",k],["__file","l2385.html.vue"]]);export{b as default};
